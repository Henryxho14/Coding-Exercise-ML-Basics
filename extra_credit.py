# -*- coding: utf-8 -*-
"""Extra credit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/143MKOn2TmAdywNRrB0ziCogpDGu8VOCI
"""

import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error
import matplotlib.pyplot as plt

# ------------------------------------------------------------
# DATASET SOURCE (download as CSV):
# FRED (Federal Reserve Bank of St. Louis) â€” Housing Starts (monthly), series: HOUST
# https://fred.stlouisfed.org/series/HOUST
# ------------------------------------------------------------

# Load dataset
df = pd.read_csv("/content/sales_data.csv")  # downloaded from FRED (HOUST)

rename_map = {"observation_date": "month", "HOUST": "sales"}
df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})

# Keep only required columns and clean types
df = df[["month", "sales"]].copy()
df["sales"] = pd.to_numeric(df["sales"], errors="coerce")
df = df.dropna(subset=["sales"])

# Convert month to a numeric index for Linear Regression
# (works whether month is an integer or a date string)
df["month_dt"] = pd.to_datetime(df["month"], errors="coerce")
if df["month_dt"].notna().all():
    df = df.sort_values("month_dt")
    df["month_num"] = (
        (df["month_dt"].dt.year - df["month_dt"].dt.year.min()) * 12
        + (df["month_dt"].dt.month - df["month_dt"].dt.month.min())
        + 1
    )
else:
    df["month_num"] = pd.to_numeric(df["month"], errors="coerce")
    df = df.dropna(subset=["month_num"]).sort_values("month_num")

# Features and target
X = df[["month_num"]]
y = df["sales"]

# Train/test split (time-ordered)
split_idx = int(len(df) * 0.8)
X_train, X_test = X.iloc[:split_idx], X.iloc[split_idx:]
y_train, y_test = y.iloc[:split_idx], y.iloc[split_idx:]

# Train the model
model = LinearRegression()
model.fit(X_train, y_train)

# Optional evaluation
test_pred = model.predict(X_test)
mae = mean_absolute_error(y_test, test_pred)
print(f"Test MAE (approx): {mae:,.2f}")

# Predict for next 6 months
last_month = int(df["month_num"].max())
future_months = pd.DataFrame({"month_num": range(last_month + 1, last_month + 7)})
predictions = model.predict(future_months)

# Plot results
plt.figure(figsize=(10, 5))
plt.plot(df["month_num"], y, label="Historical Demand (Housing Starts)")
plt.plot(future_months["month_num"], predictions, label="Forecast (Next 6 Months)", linestyle="--")
plt.axvline(last_month, linestyle="--", linewidth=1, label="Forecast Start")
plt.xlabel("Month (time index)")
plt.ylabel("Demand (sales)")
plt.title("Housing Demand Forecast (Linear Regression)")
plt.legend()
plt.tight_layout()
plt.savefig("demand_forecast.png")
plt.show()

# Assumptions / Improvements (expanded)
print("\nAssumptions & Improvements:")

print("\nAssumptions:")
print("- The dataset represents a consistent definition of demand over time (no major measurement/definition changes).")
print("- The relationship between time and demand is approximated well enough by a linear trend for a short forecast horizon (6 months).")
print("- Missing months are minimal; the time series is effectively regular (monthly) and comparable month-to-month.")
print("- The most recent historical pattern is relevant to the near future (no sudden structural break such as a major policy/rate shock).")
print("- The model treats each month as independent except for the shared trend; it does not explicitly learn momentum or lag effects.")
print("- Demand values are assumed to be numeric and comparable (e.g., counts or index values); negative values are not expected.")

print("\nChallenges / Limitations:")
print("- Seasonality: housing demand often has recurring seasonal patterns; a straight-line model can underfit those cycles.")
print("- Market shocks: interest rates, lending standards, and economic changes can shift demand quickly but are not included here.")
print("- Nonlinearity: demand may rise/fall in curves rather than a straight line (booms/busts).")
print("- Feature simplicity: using only a time index ignores helpful signals like recent momentum and macro indicators.")
print("- Forecast uncertainty: the model outputs a point estimate and does not provide confidence intervals.")

print("\nPotential Improvements:")
print("- Add seasonality features: month-of-year as one-hot, or cyclical encoding (sin/cos) to capture annual cycles.")
print("- Add lag features: previous month demand (lag_1), last 3-month average (rolling mean), and/or lag_12 (same month last year).")
print("- Add external drivers: mortgage rates, unemployment, income, inventory/listings, building permits, price index, population growth.")
print("- Use time-series validation: rolling/expanding-window cross-validation instead of a single split.")
print("- Try more flexible models: Ridge/Lasso (regularization), Gradient Boosting, Random Forest, XGBoost (if allowed).")
print("- Consider dedicated forecasting models: SARIMA/Prophet (if permitted) for trend + seasonality with uncertainty estimates.")
print("- Produce prediction intervals: bootstrap residuals or use probabilistic models to communicate uncertainty to stakeholders.")